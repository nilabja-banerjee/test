# Service Migration Prompts
metadata:
  name: "Service Layer Migration"
  description: "Convert Struts service classes to Spring Boot 3 services"
  version: "1.0"
  author: "Migration System"
  last_updated: "2025-08-02"
  success_criteria:
    - "@Service annotation"
    - "Constructor-based dependency injection"
    - "Proper transaction management"
    - "Spring Data integration where applicable"

templates:
  full_service_migration:
    name: "Full Service Migration"
    description: "Complete service layer transformation"
    template: |
      You are an expert Spring Boot developer migrating Struts service layer to Spring Boot 3.

      TASK: Convert the following Struts service class to a modern Spring Boot 3 service.

      MIGRATION CONTEXT:
      - Source: {artifact_type} service class
      - Complexity: {complexity}
      - Data Access Patterns: {data_access_patterns}
      - Transaction Requirements: {transaction_requirements}
      - Business Domain: {business_domain}

      TRANSFORMATION REQUIREMENTS:
      1. **Spring Service Layer**: Use @Service annotation
      2. **Dependency Injection**: Constructor-based injection with @Autowired
      3. **Transaction Management**: Use @Transactional where appropriate
      4. **Data Access**: Convert to Spring Data repositories
      5. **Exception Handling**: Use Spring exception hierarchy
      6. **Modern Patterns**: Apply current Spring Boot best practices

      ORIGINAL STRUTS SERVICE:
      ```java
      {source_code}
      ```

      TRANSFORMATION GUIDELINES:
      - Add @Service annotation to class
      - Convert manual dependency lookup to constructor injection
      - Replace manual transaction management with @Transactional
      - Convert DAO patterns to Spring Data repositories
      - Use Spring's exception translation
      - Apply proper logging with SLF4J
      - Add comprehensive JavaDoc

      SPECIFIC PATTERNS:
      {%- if "hibernate_session" in data_access_patterns %}
      - Replace direct Hibernate Session usage with JPA EntityManager or Repository
      {%- endif %}
      {%- if "manual_transaction" in data_access_patterns %}
      - Replace manual transaction demarcation with @Transactional
      {%- endif %}
      {%- if "service_locator" in data_access_patterns %}
      - Replace ServiceLocator pattern with Spring dependency injection
      {%- endif %}

      OUTPUT REQUIREMENTS:
      - Start with package declaration
      - Include all necessary imports
      - Complete, compilable Java class
      - NO markdown code blocks
      - NO explanatory text
      - Pure Java code only

      Generate the complete Spring Boot 3 service class:

    parameters:
      - artifact_type
      - complexity
      - data_access_patterns
      - transaction_requirements
      - business_domain
      - source_code

  repository_integration:
    name: "Service with Repository Integration"
    description: "Service migration with Spring Data repository pattern"
    template: |
      Convert this Struts service to Spring Boot 3 service with Spring Data integration.

      FOCUS AREAS:
      - Replace DAO with Spring Data repositories
      - Use @Service and @Transactional annotations
      - Implement proper exception handling
      - Apply constructor-based dependency injection

      ORIGINAL SERVICE:
      {source_code}

      REPOSITORY PATTERNS TO APPLY:
      - Create or use existing JPA repositories
      - Replace manual CRUD with repository methods
      - Use Spring Data query methods where appropriate
      - Maintain all business logic

      Generate the Spring Boot service class:

    parameters:
      - source_code

  transaction_focused:
    name: "Transaction-Focused Migration"
    description: "Migration with emphasis on transaction management"
    template: |
      Convert this service with special attention to transaction management.

      TRANSACTION REQUIREMENTS:
      - Identify transaction boundaries
      - Apply @Transactional appropriately
      - Handle rollback scenarios
      - Maintain transaction isolation levels

      ORIGINAL SERVICE:
      {source_code}

      TRANSACTION GUIDELINES:
      - Use @Transactional(readOnly = true) for read operations
      - Apply proper propagation levels
      - Handle checked exceptions with rollback
      - Optimize transaction scope

      Generate the transactional Spring service:

    parameters:
      - source_code

validation:
  success_indicators:
    - "@Service annotation present"
    - "Constructor-based dependency injection"
    - "Appropriate @Transactional usage"
    - "Spring Data repository integration"
    - "Proper exception handling"
  
  quality_checks:
    - "All business logic preserved"
    - "Proper transaction boundaries"
    - "Clean dependency management"
    - "Appropriate logging implementation"

examples:
  input:
    artifact_type: "service"
    complexity: "high"
    data_access_patterns: ["hibernate_session", "manual_transaction"]
    transaction_requirements: "manual_demarcation"
    business_domain: "user"
    source_code: |
      public class UserServiceImpl implements UserService {
          private UserDAO userDAO;
          
          public UserServiceImpl() {
              this.userDAO = DAOFactory.getUserDAO();
          }
          
          public User findUser(Long id) throws ServiceException {
              Session session = HibernateUtil.getSession();
              Transaction tx = null;
              try {
                  tx = session.beginTransaction();
                  User user = userDAO.findById(id);
                  tx.commit();
                  return user;
              } catch (Exception e) {
                  if (tx != null) tx.rollback();
                  throw new ServiceException("Error finding user", e);
              } finally {
                  session.close();
              }
          }
      }

  expected_output: |
    package com.example.service;

    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import org.springframework.beans.factory.annotation.Autowired;
    import com.example.repository.UserRepository;
    import com.example.model.User;
    import com.example.exception.ServiceException;

    @Service
    @Transactional
    public class UserServiceImpl implements UserService {
        
        private final UserRepository userRepository;
        
        @Autowired
        public UserServiceImpl(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
        
        @Transactional(readOnly = true)
        public User findUser(Long id) throws ServiceException {
            try {
                return userRepository.findById(id)
                    .orElseThrow(() -> new ServiceException("User not found with id: " + id));
            } catch (Exception e) {
                throw new ServiceException("Error finding user", e);
            }
        }
    }
