# Testing Migration Prompts
metadata:
  name: "Legacy Test to Spring Boot 3 Testing Migration"
  description: "Convert legacy JUnit/TestNG tests to modern Spring Boot 3 testing with Java 21 features"
  version: "2.0"
  author: "AI Migration System"
  last_updated: "2025-08-02"
  target_framework: "Spring Boot 3.3+"
  target_java: "Java 21 LTS"
  testing_frameworks: ["JUnit 5", "TestContainers", "MockMvc", "WebTestClient"]
  success_criteria:
    - "Complete migration from javax.* to jakarta.* namespace in test context"
    - "Modern Spring Boot 3 testing annotations (@SpringBootTest, @WebMvcTest, etc.)"
    - "Proper test slicing for optimal performance and isolation"
    - "Modern assertion libraries (AssertJ) with fluent API"
    - "Integration tests with @Testcontainers for database testing"
    - "Comprehensive mocking with @MockBean and Mockito 5+"
    - "Java 21 compatible test patterns and virtual thread safety"
    - "Test data builders and factories for maintainability"
    - "Parameterized and dynamic tests where appropriate"
    - "Security testing with @WithMockUser and custom security setup"

templates:
  comprehensive_test_migration:
    name: "Complete Legacy Test to Spring Boot 3 Migration"
    description: "Full-featured test migration with all modern Java 21 and Spring Boot 3.3+ testing capabilities"
    template: |
      You are an expert Spring Boot 3 testing architect specializing in modernizing legacy test suites to cutting-edge Java 21 and Spring Boot 3.3+ testing standards.

      TEST MIGRATION CONTEXT:
      - Source Framework: {source_test_framework} (JUnit 3/4, TestNG, Custom)
      - Target Framework: Spring Boot 3.3+ with JUnit 5 and Java 21
      - Test Type: {test_type} (unit/integration/e2e)
      - Test Scope: {test_scope} (controller/service/repository/full-stack)
      - Business Domain: {business_domain}
      - Complexity Level: {complexity}
      - Dependencies: {test_dependencies}
      - Integration Requirements: {integration_requirements}

      LEARNING CONTEXT FROM PREVIOUS TEST MIGRATIONS:
      {learning_context}

      ORIGINAL LEGACY TEST CODE:
      ```java
      {source_code}
      ```

      DETECTED LEGACY TESTING PATTERNS:
      {detected_patterns}

      COMPREHENSIVE TEST MIGRATION REQUIREMENTS:

      1. **NAMESPACE MIGRATION (CRITICAL)**:
         - Replace ALL javax.* imports with jakarta.* equivalents
         - javax.servlet.* → jakarta.servlet.*
         - javax.persistence.* → jakarta.persistence.*
         - javax.validation.* → jakarta.validation.*
         - javax.transaction.* → jakarta.transaction.*

      2. **LEGACY TEST FRAMEWORK ELIMINATION**:
         - JUnit 3: Remove extends TestCase, convert setUp/tearDown to @BeforeEach/@AfterEach
         - JUnit 4: Convert @Test to JUnit 5, update assertions to AssertJ
         - TestNG: Convert to JUnit 5 equivalent annotations and patterns
         - Remove legacy Spring test annotations (@RunWith, @ContextConfiguration)
         - Eliminate manual application context setup

      3. **MODERN SPRING BOOT 3 TEST ANNOTATIONS**:
         - @SpringBootTest for full integration tests
         - @WebMvcTest for controller layer testing
         - @DataJpaTest for repository layer testing
         - @JsonTest for JSON serialization testing
         - @TestMethodOrder(OrderAnnotation.class) for ordered tests
         - @ExtendWith(MockitoExtension.class) for pure unit tests
         - @Testcontainers with @Container for database integration

      4. **ADVANCED TEST SLICING & PERFORMANCE**:
         - Use specific test slices to load minimal Spring context
         - @MockBean for Spring beans that need mocking
         - @SpyBean for partial mocking of Spring beans
         - @TestConfiguration for test-specific bean configurations
         - @DirtiesContext only when absolutely necessary
         - @Sql for database state setup/cleanup

      5. **MODERN JAVA 21 TESTING FEATURES**:
         - Text blocks for complex test data setup
         - Pattern matching in test assertions
         - Records for immutable test data objects
         - Enhanced switch expressions for test scenarios
         - Virtual thread compatibility (avoid ThreadLocal in tests)

      6. **ASSERTION LIBRARY MODERNIZATION**:
         - Convert JUnit assertions to AssertJ fluent API
         - Use assertThat() with descriptive error messages
         - Soft assertions for multiple validations
         - Custom assertion methods for domain objects
         - Exception testing with assertThatThrownBy()

      7. **MOCKING & TEST DOUBLES**:
         - Mockito 5+ with latest features
         - @Mock for pure unit test dependencies
         - @MockBean for Spring Boot integration test mocking
         - @InjectMocks for automatic dependency injection
         - when().thenReturn() for behavior specification
         - verify() for interaction verification
         - ArgumentCaptor for complex argument verification

      8. **DATABASE & INTEGRATION TESTING**:
         - @Testcontainers for real database testing
         - @TestEntityManager for JPA repository tests
         - @Transactional with @Rollback for data cleanup
         - Test profiles with @ActiveProfiles("test")
         - In-memory databases for fast unit tests
         - Database migration testing with Flyway/Liquibase

      9. **WEB LAYER TESTING**:
         - MockMvc for servlet-based testing
         - WebTestClient for reactive testing
         - @AutoConfigureMockMvc for MockMvc auto-configuration
         - JSON path assertions for response validation
         - Security testing with @WithMockUser
         - CSRF testing for POST/PUT/DELETE operations

      10. **PARAMETERIZED & DYNAMIC TESTS**:
          - @ParameterizedTest with various sources
          - @ValueSource, @CsvSource, @MethodSource for test data
          - @DynamicTest for runtime test generation
          - @RepeatedTest for stress testing
          - @EnabledIf/@DisabledIf for conditional testing

      11. **TEST LIFECYCLE & ORGANIZATION**:
          - @DisplayName for readable test descriptions
          - @Nested classes for logical test grouping
          - @Tag for test categorization
          - @Timeout for performance testing
          - @Order for test execution sequence when needed

      LEGACY TO MODERN TEST MAPPING:
      ```
      // Legacy Pattern → Modern Spring Boot 3 Pattern
      extends TestCase → @ExtendWith(MockitoExtension.class)
      setUp() → @BeforeEach void setUp()
      tearDown() → @AfterEach void tearDown()
      assertEquals() → assertThat().isEqualTo()
      @RunWith(SpringRunner.class) → @SpringBootTest
      @ContextConfiguration → @SpringBootTest with auto-configuration
      Manual mock setup → @MockBean/@Mock with dependency injection
      Database setup → @Testcontainers with real database
      Web tests → @WebMvcTest with MockMvc
      ```

      OUTPUT REQUIREMENTS:
      - Complete, compilable test class with proper package declaration
      - All jakarta.* imports (NO javax.* imports)
      - Modern Java 21 syntax and testing patterns
      - Full Spring Boot 3 testing compatibility
      - Comprehensive test coverage preservation
      - Production-ready test quality with proper organization
      - No markdown formatting - raw Java code only
      - Include all necessary imports and static imports
      - Clear test method naming following Given_When_Then pattern

      EXAMPLE TRANSFORMATION PATTERN:
      ```java
      // OLD LEGACY PATTERN (DON'T GENERATE THIS)
      public class UserServiceTest extends TestCase {
          public void testFindUser() {
              assertEquals("expected", actual);
          }
      }
      
      // NEW SPRING BOOT 3 PATTERN (GENERATE LIKE THIS)
      @ExtendWith(MockitoExtension.class)
      class UserServiceTest {
          @Test
          @DisplayName("Should find user when valid email provided")
          void shouldFindUser_WhenValidEmailProvided() {
              assertThat(result).isNotNull().extracting(User::getEmail).isEqualTo(expected);
          }
      }
      ```

      Generate the complete, modern Spring Boot 3 test class using Java 21 features:

    parameters:
      - source_test_framework
      - test_type
      - test_scope
      - business_domain
      - complexity
      - test_dependencies
      - integration_requirements
      - source_code
      - learning_context
      - detected_patterns

  modern_unit_test_migration:
    name: "Modern Unit Test Migration"
    description: "Convert legacy unit tests to Java 21 and Spring Boot 3 unit testing patterns"
    template: |
      Convert legacy unit tests to modern Spring Boot 3 and Java 21 unit testing with advanced mocking and assertions.

      UNIT TEST CONTEXT:
      - Source Framework: {source_framework}
      - Class Under Test: {class_under_test}
      - Dependencies: {dependencies}
      - Mock Strategy: {mock_strategy}
      - Business Logic: {business_logic_type}

      ORIGINAL UNIT TEST:
      ```java
      {source_code}
      ```

      MODERN UNIT TEST REQUIREMENTS:
      - Replace ALL javax.* with jakarta.* imports
      - Use @ExtendWith(MockitoExtension.class) for pure unit tests
      - Apply @Mock for dependencies, @InjectMocks for class under test
      - Convert to AssertJ fluent assertions
      - Follow Given-When-Then (AAA) pattern with clear sections
      - Add @DisplayName for business-readable test descriptions
      - Use @ParameterizedTest for multiple test scenarios
      - Implement proper exception testing with assertThatThrownBy()

      UNIT TEST PATTERNS FOR SPRING BOOT 3:
      - Service layer tests → @ExtendWith(MockitoExtension.class) + @Mock dependencies
      - Repository tests → @DataJpaTest with @TestEntityManager
      - Controller tests → @WebMvcTest with MockMvc auto-configuration
      - Utility/Helper tests → Plain JUnit 5 with no Spring context
      - Configuration tests → @TestConfiguration with specific beans

      MODERN ASSERTION PATTERNS:
      ```java
      // Old: assertEquals(expected, actual)
      // New: assertThat(actual).isEqualTo(expected)
      
      // Old: assertTrue(condition)
      // New: assertThat(condition).isTrue()
      
      // Old: assertNotNull(object)
      // New: assertThat(object).isNotNull()
      
      // Complex assertions:
      assertThat(users)
          .hasSize(3)
          .extracting(User::getName)
          .containsExactly("John", "Jane", "Bob");
      ```

      Generate modern, comprehensive unit test class:

    parameters:
      - source_framework
      - class_under_test
      - dependencies
      - mock_strategy
      - business_logic_type
      - source_code

  testcontainers_integration_migration:
    name: "Testcontainers Integration Migration"
    description: "Convert database integration tests to Spring Boot 3 with Testcontainers"
    template: |
      Convert legacy database integration tests to modern Spring Boot 3 with Testcontainers for real database testing.

      INTEGRATION TEST CONTEXT:
      - Database Type: {database_type}
      - Integration Scope: {integration_scope}
      - Data Setup Strategy: {data_setup_strategy}
      - External Services: {external_services}

      ORIGINAL INTEGRATION TEST:
      ```java
      {source_code}
      ```

      TESTCONTAINERS MIGRATION REQUIREMENTS:
      - Replace ALL javax.* with jakarta.* imports
      - Use @SpringBootTest for full application context
      - Add @Testcontainers with appropriate database container
      - Configure @Container with proper database image
      - Use @DynamicPropertySource for container configuration
      - Apply @Transactional with @Rollback for test isolation
      - Mock external services with @MockBean
      - Use @ActiveProfiles("test") for test-specific configuration

      TESTCONTAINERS PATTERNS:
      ```java
      @SpringBootTest
      @Testcontainers
      @ActiveProfiles("test")
      class RepositoryIntegrationTest {
          
          @Container
          static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
              .withDatabaseName("testdb")
              .withUsername("test")
              .withPassword("test");
          
          @DynamicPropertySource
          static void configureProperties(DynamicPropertyRegistry registry) {
              registry.add("spring.datasource.url", postgres::getJdbcUrl);
              registry.add("spring.datasource.username", postgres::getUsername);
              registry.add("spring.datasource.password", postgres::getPassword);
          }
      }
      ```

      Generate complete Testcontainers integration test:

    parameters:
      - database_type
      - integration_scope
      - data_setup_strategy
      - external_services
      - source_code

validation:
  critical_success_indicators:
    - "Zero javax.* imports (all converted to jakarta.*)"
    - "Modern Spring Boot 3 testing annotations properly applied"
    - "AssertJ fluent assertions used throughout"
    - "Appropriate test slicing for performance optimization"
    - "Proper mocking strategy with @MockBean/@Mock"
    - "Java 21 compatible test patterns"
    - "Testcontainers for database integration where applicable"
    
  quality_metrics:
    - "All test scenarios and edge cases preserved"
    - "Test execution time improved through proper slicing"
    - "Test isolation and independence maintained"
    - "Clear test documentation with @DisplayName"
    - "No flaky tests or timing dependencies"
    - "Proper exception testing coverage"
    - "Security testing included where applicable"
    - "Memory efficiency improved"

  learning_metrics:
    - "Test compilation success rate"
    - "Test execution performance improvement"
    - "Code coverage maintenance or improvement"
    - "Test maintainability score"
    - "Integration test reliability"

examples:
  legacy_junit3_input:
    source_test_framework: "junit3"
    test_type: "unit"
    test_scope: "service"
    business_domain: "user_management"
    complexity: "medium"
    test_dependencies: ["repository", "validator", "email_service"]
    source_code: |
      package com.example.test;
      
      import junit.framework.TestCase;
      import org.mockito.Mock;
      import static org.mockito.Mockito.*;
      
      public class UserServiceTest extends TestCase {
          private UserService userService;
          private UserRepository userRepository;
          private EmailService emailService;
          
          public void setUp() {
              userRepository = mock(UserRepository.class);
              emailService = mock(EmailService.class);
              userService = new UserService(userRepository, emailService);
          }
          
          public void testCreateUser() {
              User mockUser = new User("test@example.com", "John Doe");
              when(userRepository.save(any(User.class))).thenReturn(mockUser);
              
              User result = userService.createUser("test@example.com", "John Doe");
              
              assertEquals("test@example.com", result.getEmail());
              assertEquals("John Doe", result.getName());
              
              verify(emailService).sendWelcomeEmail("test@example.com");
          }
          
          public void testCreateUserWithInvalidEmail() {
              try {
                  userService.createUser("invalid-email", "John Doe");
                  fail("Expected IllegalArgumentException");
              } catch (IllegalArgumentException e) {
                  assertEquals("Invalid email format", e.getMessage());
              }
          }
      }

  expected_spring_boot3_output: |
    package com.example.test;
    
    import org.junit.jupiter.api.DisplayName;
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.extension.ExtendWith;
    import org.mockito.InjectMocks;
    import org.mockito.Mock;
    import org.mockito.junit.jupiter.MockitoExtension;
    
    import static org.assertj.core.api.Assertions.*;
    import static org.mockito.ArgumentMatchers.any;
    import static org.mockito.ArgumentMatchers.eq;
    import static org.mockito.Mockito.verify;
    import static org.mockito.Mockito.when;
    
    /**
     * Unit tests for UserService using Spring Boot 3 and Java 21 testing patterns.
     * Migrated from JUnit 3 to modern testing framework.
     * 
     * @author Migration System
     * @since Spring Boot 3.3
     */
    @ExtendWith(MockitoExtension.class)
    @DisplayName("UserService Unit Tests")
    class UserServiceTest {
        
        @Mock
        private UserRepository userRepository;
        
        @Mock
        private EmailService emailService;
        
        @InjectMocks
        private UserService userService;
        
        @Test
        @DisplayName("Should create user successfully when valid data provided")
        void shouldCreateUser_WhenValidDataProvided() {
            // Given
            String email = "test@example.com";
            String name = "John Doe";
            User expectedUser = new User(email, name);
            when(userRepository.save(any(User.class))).thenReturn(expectedUser);
            
            // When
            User result = userService.createUser(email, name);
            
            // Then
            assertThat(result)
                .isNotNull()
                .satisfies(user -> {
                    assertThat(user.getEmail()).isEqualTo(email);
                    assertThat(user.getName()).isEqualTo(name);
                });
            
            verify(emailService).sendWelcomeEmail(eq(email));
            verify(userRepository).save(any(User.class));
        }
        
        @Test
        @DisplayName("Should throw IllegalArgumentException when invalid email provided")
        void shouldThrowException_WhenInvalidEmailProvided() {
            // Given
            String invalidEmail = "invalid-email";
            String name = "John Doe";
            
            // When & Then
            assertThatThrownBy(() -> userService.createUser(invalidEmail, name))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("Invalid email format");
        }
    }

  testcontainers_integration_example:
    database_type: "postgresql"
    integration_scope: "repository_layer"
    data_setup_strategy: "sql_scripts"
    source_code: |
      // Legacy integration test with manual database setup
      @SpringBootTest
      @TestPropertySource(locations = "classpath:application-test.properties")
      public class UserRepositoryIntegrationTest {
          
          @Autowired
          private TestEntityManager entityManager;
          
          @Autowired
          private UserRepository userRepository;
          
          @Test
          public void testFindByEmail() {
              User user = new User("test@example.com", "Test User");
              entityManager.persistAndFlush(user);
              
              Optional<User> found = userRepository.findByEmail("test@example.com");
              
              assertTrue(found.isPresent());
              assertEquals("Test User", found.get().getName());
          }
      }

    expected_testcontainers_output: |
      package com.example.repository;
      
      import org.junit.jupiter.api.DisplayName;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
      import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
      import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
      import org.springframework.test.context.ActiveProfiles;
      import org.springframework.test.context.DynamicPropertyRegistry;
      import org.springframework.test.context.DynamicPropertySource;
      import org.testcontainers.containers.PostgreSQLContainer;
      import org.testcontainers.junit.jupiter.Container;
      import org.testcontainers.junit.jupiter.Testcontainers;
      
      import static org.assertj.core.api.Assertions.assertThat;
      
      /**
       * Integration tests for UserRepository using Testcontainers with PostgreSQL.
       * Provides real database testing for repository layer.
       * 
       * @author Migration System
       * @since Spring Boot 3.3
       */
      @DataJpaTest
      @Testcontainers
      @ActiveProfiles("test")
      @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
      @DisplayName("UserRepository Integration Tests")
      class UserRepositoryIntegrationTest {
          
          @Container
          static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
              .withDatabaseName("testdb")
              .withUsername("test")
              .withPassword("test");
          
          @DynamicPropertySource
          static void configureProperties(DynamicPropertyRegistry registry) {
              registry.add("spring.datasource.url", postgres::getJdbcUrl);
              registry.add("spring.datasource.username", postgres::getUsername);
              registry.add("spring.datasource.password", postgres::getPassword);
          }
          
          @Autowired
          private TestEntityManager entityManager;
          
          @Autowired
          private UserRepository userRepository;
          
          @Test
          @DisplayName("Should find user by email when user exists in database")
          void shouldFindUserByEmail_WhenUserExistsInDatabase() {
              // Given
              String email = "test@example.com";
              String name = "Test User";
              User user = new User(email, name);
              entityManager.persistAndFlush(user);
              
              // When
              Optional<User> found = userRepository.findByEmail(email);
              
              // Then
              assertThat(found)
                  .isPresent()
                  .get()
                  .satisfies(foundUser -> {
                      assertThat(foundUser.getEmail()).isEqualTo(email);
                      assertThat(foundUser.getName()).isEqualTo(name);
                  });
          }
          
          @Test
          @DisplayName("Should return empty optional when user does not exist")
          void shouldReturnEmpty_WhenUserDoesNotExist() {
              // Given
              String nonExistentEmail = "nonexistent@example.com";
              
              // When
              Optional<User> found = userRepository.findByEmail(nonExistentEmail);
              
              // Then
              assertThat(found).isEmpty();
          }
      }
