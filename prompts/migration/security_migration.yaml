# Security Migration Prompts
metadata:
  name: "Security Migration"
  description: "Convert legacy security patterns to Spring Security"
  version: "1.0"
  author: "Migration System"
  last_updated: "2025-08-02"
  success_criteria:
    - "Spring Security configuration class with @EnableWebSecurity"
    - "Proper authentication and authorization setup"
    - "CSRF protection enabled"
    - "Secure password encoding"
    - "Session management configured"

templates:
  comprehensive_security_migration:
    name: "Comprehensive Security Migration"
    description: "Full security implementation migration to Spring Security"
    template: |
      You are an expert Spring Security architect migrating legacy authentication/authorization to Spring Security.

      SECURITY MIGRATION CONTEXT:
      - Source: {security_type} security implementation
      - Authentication Method: {auth_method}
      - Authorization Patterns: {auth_patterns}
      - Session Management: {session_management}
      - Security Constraints: {security_constraints}

      ORIGINAL SECURITY CODE:
      ```java
      {source_code}
      ```

      DETECTED PATTERNS:
      {detected_patterns}

      TRANSFORMATION REQUIREMENTS:
      1. **Security Configuration**: Create @Configuration class with @EnableWebSecurity
      2. **Authentication**: Set up AuthenticationManager and UserDetailsService
      3. **Authorization**: Configure method-level and URL-based security
      4. **Password Encoding**: Use BCryptPasswordEncoder or Argon2
      5. **Session Management**: Configure session creation policy and timeout
      6. **CSRF Protection**: Enable CSRF for form-based authentication
      7. **Login/Logout**: Configure custom login and logout handlers
      8. **Remember Me**: Set up remember-me functionality if needed

      LEGACY TO SPRING SECURITY MAPPING:
      - Custom filters → SecurityFilterChain configuration
      - Role-based access → @PreAuthorize or antMatchers
      - Session validation → SessionManagementConfigurer
      - Login forms → formLogin() configuration
      - Logout handling → logout() configuration
      - Password validation → PasswordEncoder beans

      SECURITY CONFIGURATION PATTERNS:
      - URL Security: `.requestMatchers("/admin/**").hasRole("ADMIN")`
      - Method Security: `@PreAuthorize("hasRole('USER')")`
      - Custom Login: `.formLogin().loginPage("/login").permitAll()`
      - Logout: `.logout().logoutSuccessUrl("/").permitAll()`
      - Session: `.sessionManagement().maximumSessions(1)`

      OUTPUT REQUIREMENTS:
      - SecurityConfig class with @EnableWebSecurity
      - UserDetailsService implementation if custom users
      - PasswordEncoder bean configuration
      - Custom authentication success/failure handlers if needed
      - SecurityFilterChain bean configuration
      - Complete, production-ready security setup

      Generate the complete Spring Security configuration:

    parameters:
      - security_type
      - auth_method
      - auth_patterns
      - session_management
      - security_constraints
      - source_code
      - detected_patterns

  authentication_migration:
    name: "Authentication Migration"
    description: "Convert custom authentication to Spring Security"
    template: |
      Convert custom authentication logic to Spring Security authentication.

      AUTHENTICATION CONTEXT:
      - Current Method: {current_auth_method}
      - User Storage: {user_storage_type}
      - Password Handling: {password_handling}

      ORIGINAL AUTHENTICATION CODE:
      {source_code}

      REQUIREMENTS:
      - Create UserDetailsService implementation
      - Set up AuthenticationProvider if custom logic needed
      - Configure password encoding
      - Implement proper authentication flow
      - Add authentication failure handling

      AUTHENTICATION PATTERNS:
      - Database users → JdbcUserDetailsService or custom UserDetailsService
      - LDAP users → LdapAuthenticationProvider
      - Custom validation → Custom AuthenticationProvider
      - Remember me → RememberMeServices configuration

      Generate Spring Security authentication configuration:

    parameters:
      - current_auth_method
      - user_storage_type
      - password_handling
      - source_code

  authorization_migration:
    name: "Authorization Migration"
    description: "Convert role-based access control to Spring Security"
    template: |
      Convert custom authorization logic to Spring Security authorization.

      AUTHORIZATION CONTEXT:
      - Access Control Type: {access_control_type}
      - Role Hierarchy: {role_hierarchy}
      - Permission Model: {permission_model}

      ORIGINAL AUTHORIZATION CODE:
      {source_code}

      REQUIREMENTS:
      - Configure URL-based security with antMatchers
      - Set up method-level security with @PreAuthorize
      - Implement custom access decision voters if needed
      - Configure role hierarchy if applicable
      - Add proper access denied handling

      AUTHORIZATION PATTERNS:
      - URL access → `.requestMatchers("/api/**").hasRole("USER")`
      - Method access → `@PreAuthorize("hasPermission(#id, 'READ')")`
      - Custom logic → Custom PermissionEvaluator
      - Role hierarchy → RoleHierarchy bean

      Generate Spring Security authorization configuration:

    parameters:
      - access_control_type
      - role_hierarchy
      - permission_model
      - source_code

validation:
  success_indicators:
    - "@EnableWebSecurity annotation present"
    - "SecurityFilterChain bean configured"
    - "PasswordEncoder bean defined"
    - "Proper authentication setup"
    - "Authorization rules properly configured"
    - "CSRF protection configured"
  
  quality_checks:
    - "All security constraints preserved"
    - "Proper exception handling"
    - "Session management configured"
    - "Login/logout flows working"
    - "Password security improved"
    - "No security vulnerabilities introduced"

examples:
  input:
    security_type: "custom"
    auth_method: "database"
    auth_patterns: ["role_based", "url_protection"]
    session_management: "stateful"
    security_constraints: ["admin_only", "user_access"]
    source_code: |
      public class SecurityFilter implements Filter {
          public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
              HttpServletRequest req = (HttpServletRequest) request;
              String username = req.getParameter("username");
              String password = req.getParameter("password");
              
              if (validateUser(username, password)) {
                  req.getSession().setAttribute("user", username);
                  chain.doFilter(request, response);
              } else {
                  ((HttpServletResponse) response).sendRedirect("/login");
              }
          }
      }

  expected_output: |
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig {
        
        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
        
        @Bean
        public UserDetailsService userDetailsService() {
            return new CustomUserDetailsService();
        }
        
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http
                .authorizeHttpRequests(authz -> authz
                    .requestMatchers("/admin/**").hasRole("ADMIN")
                    .requestMatchers("/user/**").hasRole("USER")
                    .requestMatchers("/login", "/register").permitAll()
                    .anyRequest().authenticated()
                )
                .formLogin(form -> form
                    .loginPage("/login")
                    .defaultSuccessUrl("/dashboard")
                    .permitAll()
                )
                .logout(logout -> logout
                    .logoutSuccessUrl("/")
                    .permitAll()
                )
                .sessionManagement(session -> session
                    .maximumSessions(1)
                    .maxSessionsPreventsLogin(false)
                );
            
            return http.build();
        }
    }
