You are a Spring Boot expert handling complex service layer migrations where interfaces have multiple implementations and require sophisticated dependency injection strategies.

---

## ðŸ“Œ Context:
The legacy service `{service_class}` depends on interface `{interface_name}` with implementations `{impl_classes}`. You need to implement a fallback strategy for dependency injection.

---

## âœ… Instructions:

1. Convert `{service_class}` to a Spring Boot service with `@Service` annotation.

2. Implement primary/fallback injection strategy:
   - Use `@Primary` on the main implementation
   - Use `@Qualifier` for specific implementations
   - Implement conditional injection with `@ConditionalOnProperty`

3. Add configuration properties for dynamic selection:
```properties
app.service.{service_name}.implementation={default_impl}
app.service.{service_name}.fallback.enabled=true
```

4. Preserve all business logic and add proper transaction management with `@Transactional`.

5. Add comprehensive error handling and logging.

---

## ðŸ”§ Fallback Strategy Template:

```java
@Service
public class {service_class} {{

    private final {interface_name} primaryService;
    private final {interface_name} fallbackService;
    
    @Autowired
    public {service_class}(
        @Qualifier("{primary_bean}") {interface_name} primaryService,
        @Qualifier("{fallback_bean}") {interface_name} fallbackService) {{
        this.primaryService = primaryService;
        this.fallbackService = fallbackService;
    }}
    
    @Transactional
    public ResultType processRequest(RequestType request) {{
        try {{
            return primaryService.process(request);
        }} catch (Exception e) {{
            logger.warn("Primary service failed, using fallback", e);
            return fallbackService.process(request);
        }}
    }}
}}
```

---

## ðŸŽ¯ Migration Requirements:

### Original Service Code:
```java
{service_code}
```

### Analysis Context:
{analysis}

### Target Requirements:
- Java Version: {target_java_version}
- Spring Boot Version: 3.2.0
- Interface: {interface_name}
- Available Implementations: {impl_classes}
- Primary Bean: {primary_bean}
- Fallback Bean: {fallback_bean}
- Fallback Strategy: {fallback_strategy}

### STRICT OUTPUT REQUIREMENTS:
1. Generate ONLY valid Java code - no explanations
2. Include proper Spring Boot annotations
3. Implement robust fallback mechanism
4. Add @Transactional where appropriate
5. Include proper exception handling
6. Use SLF4J logging for fallback scenarios
7. Preserve all original business logic

Generate the complete Spring Service class with fallback injection strategy:
