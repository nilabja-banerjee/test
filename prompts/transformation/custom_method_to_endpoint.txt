You are transforming a custom public method inside a Struts Action class into a Spring Boot REST endpoint.

## Goal:
Convert custom Action methods (beyond execute()) into proper Spring Boot controller endpoints while preserving method names, signatures, and all business logic.

---

## Guidelines:
1. **NEVER RENAME METHODS**: Keep original method names unless explicitly instructed
2. **PRESERVE METHOD PURPOSE**: Maintain the original intent and functionality
3. **SMART PARAMETER CONVERSION**: Convert Struts parameters to Spring Boot equivalents
4. **RETAIN HELPER METHODS**: If it's a utility/helper method, retain as-is (no mapping annotation)
5. **MAINTAIN ALL LOGIC**: Every conditional, loop, validation, and business rule must be preserved

---

## Conversion Rules:

### For HTTP Endpoint Methods:
- `ActionMapping` → Remove (handled by class-level `@RequestMapping`)
- `ActionForm` → `@RequestBody FormDTO` or individual `@RequestParam`
- `HttpServletRequest` → `@RequestParam` or `@PathVariable` for specific parameters
- `HttpServletResponse` → Remove (handled by ResponseEntity)
- `return ActionForward` → `return ResponseEntity<T>`

### For Utility/Helper Methods:
- Keep method signature unchanged
- Preserve private/protected access modifiers
- No Spring annotations needed
- Maintain all internal logic

---

## Analysis Context:
{analysis}

## Original Custom Method:
```java
{custom_method_code}
```

## Method Classification:
- Method Type: {method_type} (endpoint|helper|utility)
- Access Level: {access_level}
- Expected HTTP Method: {http_method}
- Parameters Found: {parameters}

---

## Transformation Patterns:

### Endpoint Method Transformation:
```java
// FROM: public ActionForward customAction(ActionMapping mapping, ActionForm form, 
//                                        HttpServletRequest request, HttpServletResponse response)
// TO:   @PostMapping("/custom")
//       public ResponseEntity<CustomResponseDTO> customAction(@RequestBody CustomFormDTO form)

// FROM: public ActionForward validateUser(ActionMapping mapping, ActionForm form,
//                                        HttpServletRequest request, HttpServletResponse response)
// TO:   @PostMapping("/validate")
//       public ResponseEntity<ValidationResult> validateUser(@RequestParam String userId,
//                                                            @RequestParam String token)
```

### Helper Method Preservation:
```java
// KEEP UNCHANGED: private String formatUserName(String firstName, String lastName)
// KEEP UNCHANGED: protected boolean isValidEmail(String email)
// KEEP UNCHANGED: private List<String> parseCommaSeparatedValues(String input)
```

### Parameter Mapping Examples:
```java
// FROM: String value = request.getParameter("param");
// TO:   @RequestParam String param

// FROM: String id = request.getParameter("userId");
// TO:   @RequestParam("userId") String id

// FROM: FormBean form with getters/setters
// TO:   @RequestBody FormDTO form OR individual @RequestParam for each field
```

---

## Example Transformation:

**Input (Custom Endpoint Method):**
```java
public ActionForward validateCredentials(ActionMapping mapping, ActionForm form,
        HttpServletRequest request, HttpServletResponse response) throws Exception {
    
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    String captcha = request.getParameter("captcha");
    
    // Validate captcha first
    if (!captchaService.isValid(captcha)) {
        request.setAttribute("error", "Invalid captcha");
        return mapping.findForward("loginError");
    }
    
    // Validate credentials
    User user = authService.authenticate(username, password);
    if (user == null) {
        request.setAttribute("error", "Invalid credentials");
        return mapping.findForward("loginError");
    }
    
    // Set session
    HttpSession session = request.getSession();
    session.setAttribute("user", user);
    
    request.setAttribute("user", user);
    return mapping.findForward("dashboard");
}
```

**Expected Output:**
```java
@PostMapping("/validate-credentials")
public ResponseEntity<?> validateCredentials(@RequestParam String username,
                                           @RequestParam String password,
                                           @RequestParam String captcha,
                                           HttpSession session) {
    
    // Validate captcha first
    if (!captchaService.isValid(captcha)) {
        return ResponseEntity.badRequest().body(Map.of("error", "Invalid captcha"));
    }
    
    // Validate credentials
    User user = authService.authenticate(username, password);
    if (user == null) {
        return ResponseEntity.badRequest().body(Map.of("error", "Invalid credentials"));
    }
    
    // Set session
    session.setAttribute("user", user);
    
    return ResponseEntity.ok(Map.of("user", user, "redirectUrl", "/dashboard"));
}
```

**Input (Helper Method):**
```java
private String sanitizeInput(String input) {
    if (input == null) return "";
    return input.trim().replaceAll("[<>\"']", "");
}

protected boolean hasPermission(User user, String action) {
    return user != null && user.getPermissions().contains(action);
}
```

**Expected Output (UNCHANGED):**
```java
private String sanitizeInput(String input) {
    if (input == null) return "";
    return input.trim().replaceAll("[<>\"']", "");
}

protected boolean hasPermission(User user, String action) {
    return user != null && user.getPermissions().contains(action);
}
```

---

## Critical Requirements:
1. **PRESERVE METHOD NAMES**: Never change custom method names unless explicitly required
2. **MAINTAIN ACCESS LEVELS**: Keep private/protected methods as-is
3. **COMPLETE LOGIC PRESERVATION**: Every line of business logic must be retained
4. **SMART CLASSIFICATION**: Distinguish between HTTP endpoints and utility methods
5. **PARAMETER FIDELITY**: All original parameters must be accessible in the new signature
6. **RESPONSE CONSISTENCY**: Maintain the same data flow and response patterns
7. **SESSION HANDLING**: Preserve session management where used
8. **EXCEPTION PRESERVATION**: Maintain all error handling and exception throwing

## Method Classification Logic:
- **Endpoint Method**: Returns ActionForward, uses ActionMapping/ActionForm parameters, handles HTTP requests
- **Helper Method**: Private/protected, used internally, no ActionForward return, utility purpose
- **Utility Method**: Static or instance methods for data processing, validation, formatting

**IMPORTANT**: 
- Only add Spring mapping annotations to methods that were actual HTTP request handlers
- Preserve all helper and utility methods exactly as they were
- Maintain method visibility (private, protected, public)
- Keep the same return types for non-endpoint methods
