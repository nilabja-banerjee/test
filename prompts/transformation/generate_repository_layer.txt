You are an expert Java developer specializing in Spring Data JPA and repository patterns. Generate a repository layer from the provided service code.

## Service Code:
```java
{{service_code}}
```

## Data Access Analysis:
{data_access_patterns}

## Repository Layer Generation Requirements:

### 1. Repository Interface Design
- Extend appropriate Spring Data repository interfaces (`JpaRepository`, `CrudRepository`, etc.)
- Define custom query methods using Spring Data query derivation
- Create custom queries using `@Query` annotation when needed
- Follow Spring Data naming conventions

### 2. Entity Mapping
- Ensure proper JPA entity relationships
- Define appropriate repository methods for entity operations
- Consider pagination and sorting requirements
- Handle complex queries efficiently

### 3. Query Methods
- Use Spring Data query derivation for simple queries
- Implement custom queries for complex operations
- Consider performance implications of queries
- Use appropriate return types (Optional, List, Page, etc.)

### 4. Repository Implementation
- Let Spring Data provide default implementations
- Create custom repository implementations only when necessary
- Use `@Repository` annotation for custom implementations
- Implement proper exception handling

## Example Repository Structure:
```java
// Basic Repository Interface
public interface ExampleRepository extends JpaRepository<ExampleEntity, Long> {{
    
    // Query derivation
    Optional<ExampleEntity> findByName(String name);
    List<ExampleEntity> findByStatusAndCreatedDateBetween(Status status, LocalDateTime start, LocalDateTime end);
    
    // Custom query
    @Query("SELECT e FROM ExampleEntity e WHERE e.category = :category ORDER BY e.createdDate DESC")
    List<ExampleEntity> findByCategoryOrderedByDate(@Param("category") String category);
    
    // Native query for complex operations
    @Query(value = "SELECT * FROM example_table WHERE complex_condition = ?1", nativeQuery = true)
    List<ExampleEntity> findByComplexCondition(String condition);
}}

// Custom Repository (if needed)
public interface ExampleCustomRepository {{
    List<ExampleEntity> findByComplexCriteria(SearchCriteria criteria);
}}

@Repository
public class ExampleCustomRepositoryImpl implements ExampleCustomRepository {{
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public List<ExampleEntity> findByComplexCriteria(SearchCriteria criteria) {{
        // Custom implementation using EntityManager
    }}
}}
```

## Output Requirements:

Generate the complete repository layer in the following format:

```json
{{
  "RepositoryName": {{
    "repository_code": "Complete repository interface code here",
    "custom_repository_code": "Custom repository implementation if needed (or null)",
    "description": "What this repository manages",
    "entity_name": "Associated entity name"
  }},
  "AnotherRepositoryName": {{
    "repository_code": "Complete repository interface code here",
    "custom_repository_code": "Custom repository implementation if needed (or null)", 
    "description": "What this repository manages",
    "entity_name": "Associated entity name"
  }}
}}
```

## Guidelines:

1. **Interface Design**: Extend appropriate Spring Data repository interfaces
2. **Query Methods**: Use query derivation for simple queries, `@Query` for complex ones
3. **Method Naming**: Follow Spring Data query method naming conventions
4. **Return Types**: Use appropriate return types (Optional for single results, List/Page for collections)
5. **Parameters**: Use `@Param` annotation for named parameters in custom queries
6. **Performance**: Consider query performance and use appropriate indexes
7. **Transactions**: Repository methods are transactional by default in service layer

## Entity Assumptions:
- Assume standard JPA entity structure with `@Entity` annotation
- Primary key of type `Long` with `@Id` and `@GeneratedValue`
- Standard JPA column mappings
- Proper entity relationships if applicable

**IMPORTANT**: 
- Generate complete, compilable Java code
- Include all necessary imports (Spring Data JPA, JPA annotations)
- Follow Spring Data JPA best practices
- Ensure repository methods match service layer requirements
- Use appropriate Spring Data features (pagination, query derivation, etc.)
- Generate only repository interfaces unless custom implementation is truly needed
